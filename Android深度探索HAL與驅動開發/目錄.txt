目錄：
第一篇　Android驅動開發前的準備　1

第1章　Android系統移植與驅動開發概述　3
1.1　Android系統架構　3
1.2　Android系統移植的主要工作　4
1.3　查看Linux內核版本　5
1.4　Linux內核版本號的定義規則　6
1.5　如何學習Linux驅動開發　7
1.6　Linux設備驅動　8
1.6.1　設備驅動的發展和作用　8
1.6.2　設備的分類及特點　9
1.7　 見識一下什么叫Linux驅動：LED　9
1.8　小結　11

第2章　搭建Android開發環境　12
2.1　Android底層開發需要哪些工具　12
2.2　安裝JDK　13
2.3　搭建Android應用程序開發環境　13
2.3.1　安裝Android SDK　13
2.3.2　安裝Eclipse　15
2.3.3　安裝ADT　16
2.3.4　配置ADT　18
2.3.5　建立AVD　19
2.4　安裝Android NDK開發環境　20
2.4.1　下載Android NDK　20
2.4.2　安裝CDT　21
2.4.3　命令行方式編譯Android NDK程序　21
2.4.4　導入Android NDK的例子　22
2.4.5　配置Android NDK的集成開發環境　22
2.5　安裝交叉編譯環境　25
2.6　小結　28

第3章　Git使用入門　29
3.1　安裝Git　29
3.2　查看Git文檔　30
3.3　源代碼的提交與獲取　31
3.3.1　創建版本庫：git init　31
3.3.2　將文件提交到本地版本庫：git commit　32
3.3.3　創建本地分支：git branch　33
3.3.4　切換本地分支：git checkout　34
3.3.5　在GitHub上創建開源項目　34
3.3.6　上傳源代碼到GitHub：git push　36
3.3.7　從GitHub下載源代碼：git clone　39
3.4　小結　39

第4章　源代碼的下載和編譯　41
4.1　下載、編譯和測試Android源代碼　41
4.1.1　配置Android源代碼下載環境　41
4.1.2　Android源代碼目錄結構解析　43
4.1.3　下載Android源代碼中的一部分　44
4.1.4　編譯Android 源代碼　46
4.1.5　out目錄結構分析　48
4.1.6　將自己的APK作為Android內置程序發布　49
4.1.7　用模擬器測試system.img文件　50
4.2　下載和編譯Linux內核源代碼　51
4.2.1　下載Linux內核源代碼　51
4.2.2　Linux內核源代碼的目錄結構　51
4.2.3　安裝Android內核的編譯環境　52
4.2.4　配置和編譯Linux內核　53
4.3　小結　57

第5章　搭建S3C6410開發板的測試環境　58
5.1　S3C6410開發板簡介　58
5.2　安裝串口調試工具：minicom　60
5.3　燒寫Android系統　62
5.4　配置有線網絡　65
5.5　小結　66

第二篇　Android底層開發入門　67

第6章　第一個Linux驅動程序：統計單詞個數　69
6.1　Linux驅動到底是個什么東西　69
6.2　編寫Linux驅動程序的步驟　70
6.3　第一個Linux驅動：統計單詞個數　71
6.3.1　編寫Linux驅動程序前的準備工作　72
6.3.2　編寫Linux驅動程序的骨架(初始化和退出驅動)　72
6.3.3　指定與驅動相關的信息　75
6.3.4　注冊和注銷設備文件　78
6.3.5　指定回調函數　80
6.3.6　實現統計單詞數的算法　84
6.3.7　編譯、安裝、卸載Linux驅動程序　87
6.4　使用多種方式測試Linux驅動　88
6.4.1　使用Ubuntu Linux測試Linux驅動　88
6.4.2　在Android模擬器上通過原生(Native)C程序測試Linux驅動　90
6.4.3　使用Android NDK測試Linux驅動　93
6.4.4　使用Java代碼直接操作設備文件來測試Linux驅動　98
6.4.5　使用S3C6410開發板測試Linux驅動　100
6.4.6　將驅動編譯進Linux內核進行測試　101
6.5　使用Eclipse開發和測試Linux驅動程序　105
6.5.1　在Eclipse中開發Linux驅動程序　105
6.5.2　在Eclipse中測試Linux驅動　109
6.6　小結　110

第7章　LED將為我閃爍：控制發光二級管　111
7.1　LED驅動的實現原理　111
7.2　編寫LED驅動　112
7.2.1　體驗LED驅動的奇妙　112
7.2.2　創建LED驅動的設備文件　113
7.2.3　卸載LED驅動的設備文件　118
7.2.4　設置寄存器與初始化LED驅動　118
7.2.5　控制LED　121
7.2.6　LED驅動的模塊參數　123
7.2.7　LED驅動的完整代碼　125
7.3　測試LED驅動　129
7.3.1　編寫測試I/O控制命令的通用程序　130
7.3.2　使用NDK測試LED驅動　132
7.3.3　使用Java測試LED驅動　135
7.4　LED驅動的移植　136
7.5　小結　138

第8章　讓開發板發出聲音：蜂鳴器驅動　139
8.1　Linux驅動的代碼重用　139
8.1.1　編譯是由多個文件組成的Linux驅動　139
8.1.2　Linux驅動模塊的依賴(導出符號)　142
8.2　強行卸載Linux驅動　146
8.3　蜂鳴器(PWM)驅動　151
8.3.1　蜂鳴器驅動的原理　151
8.3.2　實現蜂鳴器驅動　152
8.3.3　測試蜂鳴器驅動　155
8.4　小結　155

第9章　硬件抽象層：HAL　156
9.1　為什么要在Android中加入HAL　156
9.2　Android HAL架構　157
9.3　為LED驅動增加HAL　158
9.3.1　編寫一款支持HAL的Linux驅動程序的步驟　159
9.3.2　顛覆Linux驅動的設計理念：精簡LED驅動　159
9.3.3　測試讀寫寄存器操作　166
9.3.4　編寫調用LED驅動的HAL模塊　169
9.3.5　編寫調用HAL模塊的Service　178
9.3.6　HAL模塊的存放路徑和命名規則　182
9.3.7　編寫調用Service的Java庫　186
9.3.8　測試LED驅動　187
9.4　小結　188

第10章　嵌入式Linux的調試技術　189
10.1　打印內核調試信息：printk　189
10.2　防止printk函數降低Linux 驅動性能　192
10.3　通過虛擬文件系統(/proc)進行數據交互　195
10.4　調試工具　200
10.4.1　用gdb調試用戶空間程序　200
10.4.2　用gdbserver遠程調試用戶空間程序　201
10.4.3　用kgdb遠程調試內核程序　203
10.5　小結　204

第三篇　Linux驅動開發高級技術　205

第11章　Linux驅動程序中的并發控制　207
11.1　并發和競態　207
11.2 原子操作　208
11.2.1　整型原子操作　208
11.2.2　64位整型原子操作　210
11.2.3　位原子操作　211
11.2.4　用原子操作阻止設備文件被多個進程打開　212
11.3 自旋鎖(Spin Lock)　214
11.3.1　自旋鎖的使用方法　215
11.3.2　使用自旋鎖保護臨界區　217
11.3.3　讀寫自旋鎖　220
11.3.4　使用讀寫自旋鎖保護臨界區　223
11.3.5　順序鎖(seqlock)　228
11.3.6　使用順序鎖寫入正在讀取的共享資源　230
11.4　讀—復制—更新(RCU)機制　232
11.4.1　RCU的原理　232
11.4.2　RCU API　234
11.4.3　RCU的應用　237
11.5　信號量(Semaphore)　238
11.5.1　信號量的使用　239
11.5.2　信號量用于同步　240
11.5.3　讀寫信號量　242
11.5.4　使用讀寫信號量保護臨界區　243
11.6　互斥體(Mutex)　245
11.7　完成量(Completion)　248
11.8　小結　252

第12章　Linux驅動程序中的阻塞和非阻塞I/O　253
12.1　等待隊列　253
12.1.1　等待隊列原理　253
12.1.2　等待隊列的API　254
12.1.3　等待隊列的使用方法　258
12.1.4　支持休眠和喚醒的Linux驅動　258
12.2　輪詢操作　261
12.2.1　用戶空間的select函數　261
12.2.2　內核空間的poll函數　261
12.2.3　以非阻塞的方式訪問Linux驅動　262
12.3 小結　266

第13章　Linux驅動程序中的異步編程　267
13.1　信號與異步通知　267
13.1.1　Linux信號　267
13.1.2　接收Linux信號　268
13.1.3　發送信號　271
13.2　異步I/O(AIO)　276
13.2.1　異步操作的API　277
13.2.2　異步讀寫本地文件　280
13.2.3　Linux驅動中的異步函數(aio_read和aio_write)　282
13.2.4　接收信號時異步讀取數據　283
13.2.5　AIO中的回調函數　285
13.3　小結　286

第14章　Linux中斷和底半部　287
14.1　什么是中斷　287
14.2　中斷處理程序　288
14.3　Linux 中斷處理的核心：頂半部和底半部　288
14.4　獲取Linux 系統的中斷統計信息　289
14.5　Linux 中斷編程　290
14.5.1　注冊中斷處理程序　290
14.5.2　注銷中斷處理程序　293
14.5.3　編寫中斷處理函數　293
14.5.4　共享中斷處理程序　294
14.5.5　禁止和激活中斷　294
14.5.6　禁止和激活中斷線　295
14.5.7　獲取中斷系統的狀態　296
14.5.8　與中斷編程相關的函數和宏　296
14.6　實例：S3C6410實時鐘中斷　297
14.7　中斷中下文　299
14.8　中斷的實現原理　300
14.9　底半部　303
14.9.1　為什么要使用底半部　304
14.9.2　實現底半部的機制　304
14.9.3　軟中斷　305
14.9.4　Tasklet　309
14.9.5　實例：Tasklet演示　313
14.9.6　軟中斷處理線程(ksoftirqd)　314
14.9.7　工作隊列(work queue)　315
14.9.8　與工作隊列相關的API　321
14.9.9　實例：工作隊列演示　322
14.10　小結　324

第15章　時間管理　325
15.1　Linux內核中的時間概念　325
15.1.1　時鐘頻率　326
15.1.2　提高時鐘頻率的優點和缺點　326
15.2　節拍總數(jiffies)　327
15.2.1　訪問jiffies　328
15.2.2　jiffies、時間和時鐘頻率之間的轉換　328
15.2.3　jiffies的回繞　331
15.2.4　用戶空間和時鐘頻率　332
15.3　實時時鐘和定時器　333
15.4　時鐘中斷處理程序的實現　334
15.5　讀寫本地時間　337
15.6　內核定時器　340
15.6.1　如何使用內核定時器　341
15.6.2　實例：秒表定時器　343
15.7　內核延遲　347
15.7.1　忙等待　347
15.7.2　短延遲　348
15.7.3　休眠延遲(schedule_timeout)　349
15.8　小結　351

第16章　內存管理與I/O訪問　352
16.1　內存管理模式　352
16.1.1　內存的基本單位：頁(Page)　352
16.1.2　頁的邏輯劃分：區(zone)　354
16.1.3　獲取頁　361
16.1.4　釋放頁　363
16.2　分配連續的內存空間(Kmalloc)　364
16.2.1　gfp_mask標志　365
16.2.2　釋放內存(kfree)　368
16.3　分配不連續的內存空間(vmalloc)　369
16.4　全局緩存(slab)　370
16.4.1　Slab層的實現原理　371
16.4.2　Slab分配器　373
16.4.3　示例：從Slab高速緩存中分配和釋放對象　375
16.5　Linux內存池　376
16.5.1　內存池的實現原理　377
16.5.2　示例：從內存池獲取對象　381
16.6　虛擬地址與物理地址之間的轉換　384
16.7　設備I/O端口與I/O內存　385
16.7.1　讀寫I/O端口　385
16.7.2　讀寫I/O內存　385
16.7.3　將I/O端口映射為I/O內存　387
16.7.4　申請和釋放設備I/O端口和I/O內存　387
16.7.5　使用設備I/O端口和I/O內存的一般步驟　388
16.8　內核空間與用戶空間共享數據　389
16.8.1　內存映射與VMA　390
16.8.2　示例：用戶程序讀取內核空間數據　392
16.9　I/O內存靜態映射　395
16.10　小結　397

第四篇　Linux設備驅動與Android底層開發　399

第17章　RTC驅動　401
17.1　實時時鐘(RTC)結構與移植內容　401
17.1.1　RTC系統的結構　401
17.1.2　RTC驅動主要的移植工作　403
17.2　RTC系統中的Android部分　403
17.2.1　警報管理：AlarmManager　403
17.2.2　警報服務：AlarmManagerService　406
17.2.3　直接與Alarm驅動交互的JNI代碼　409
17.3　Alarm驅動的分析與移植　411
17.3.1　Alarm驅動簡介　411
17.3.2　Alarm驅動中的關鍵數據結構　412
17.3.3　Alarm驅動的應用層接口(alarm_dev.c)代碼分析　414
17.3.4　Alarm驅動的通用文件(alarm.c)代碼分析　419
17.4　RTC驅動的分析與移植　423
17.4.1　實時時鐘(RTC)的特性　423
17.4.2　RTC的結構　423
17.4.3　RTC芯片的寄存器　425
17.4.4　RTC驅動的用戶空間接口　427
17.4.5　RTC系統組件之間的調用關系　428
17.4.6　設備文件(/dev/rtc0)的I/O命令　435
17.4.7　sysfs虛擬文件處理函數　437
17.4.8　proc虛擬文件處理函數　438
17.5　小結　440

第18章　LCD驅動　441
18.1　LCD簡介　441
18.1.1　液晶的工作原理　441
18.1.2　LCD的種類　442
18.1.3　LCD的技術參數　444
18.1.4　LCD時序圖　444
18.2　LCD驅動結構分析和移植要點　446
18.3　幀緩沖(FrameBuffer)驅動設計與實現　447
18.3.1　FrameBuffer設備　447
18.3.2　示例：通過dd命令與FrameBuffer設備文件交互　448
18.3.3　示例：編寫訪問FrameBuffer設備文件的程序　449
18.3.4　FrameBuffer驅動的架構　451
18.3.5　FrameBuffer驅動主要的數據結構　452
18.3.6　如何在Linux內核中查找指定的內容　455
18.3.7　FrameBuffer驅動設備事件的處理(fbmem.c)　458
18.3.8　FrameBuffer驅動源代碼分析與移植　461
18.4　FrameBuffer驅動的HAL層分析　469
18.4.1　Gralloc庫　469
18.4.2　初始化HAL Gralloc的核心結構體　470
18.4.3　獲取Gralloc HAL模塊　472
18.4.4　與FrameBuffer設備文件交互　475
18.5　調用Gralloc HAL庫　478
18.6　小結　481

第19章　音頻驅動　482
19.1　音頻驅動基礎　482
19.1.1　數字音頻簡介　482
19.1.2　ALSA架構簡介　483
19.1.3　ALSA設備文件　483
19.1.4　數字采樣與數字錄音　484
19.1.5　混音器　485
19.1.6　音頻驅動的目錄結構　486
19.1.7　音頻設備硬件接口　487
19.1.8　ALSA架構支持的聲卡芯片　488
19.2　AC97芯片的寄存器　489
19.2.1　控制寄存器　489
19.2.2　狀態寄存器　490
19.2.3　編解碼器命令寄存器　490
19.2.4　編解碼器狀態寄存器　491
19.2.5　PCM輸出/輸入通道FIFO數據寄存器　491
19.2.6　MIC輸入通道FIFO地址寄存器　491
19.2.7　PCM輸出/輸入通道FIFO數據寄存器　492
19.2.8　MIC輸入通道FIFO數據寄存器　492
19.3　創建聲卡　492
19.3.1　聲卡的頂層數據結構　492
19.3.2　創建聲卡的步驟　493
19.3.3　示例：基于ARM的AC97音頻驅動　496
19.4　音頻邏輯設備　501
19.4.1　創建PCM設備　501
19.4.2　創建錄音和播放設備文件節點　504
19.4.3　創建Control設備數據結構　508
19.4.4　創建Control設備　514
19.4.5　注冊與打開音頻字符設備　515
19.5　嵌入式設備中的ALSA(ASoC)　516
19.5.1　什么是ASoC　517
19.5.2　ASoC的硬件架構　517
19.5.3　ASoC的軟件架構　518
19.5.4　如何確定S3C開發板使用了哪個音頻驅動　518
19.5.5　ASoC架構中的Machine　520
19.5.6　ASoC架構中的Codec　529
19.5.7　ASoC架構中的Platform　531
19.6　音頻驅動的HAL分析　534
19.6.1　實現HAL Library　534
19.6.2　調用HAL Library　541
19.7　小結　545

第20章　Linux塊設備驅動　546
20.1　塊設備簡介　546
20.2　塊設備的體系架構　546
20.3　塊設備的數據結構與相關操作　549
20.3.1　磁盤設備(gendisk結構體)　549
20.3.2　block_device_operations結構體　550
20.3.3　I/O請求(request結構體)　551
20.3.4　請求隊列(request_queue結構體)　553
20.3.5　塊I/O(bio結構體)　555
20.4　塊設備的加載和卸載　557
20.5　塊設備的打開和釋放　559
20.6　塊設備的ioctl函數　559
20.7　塊設備驅動的I/O請求處理　560
20.7.1　依賴請求隊列　560
20.7.2　不依賴請求隊列　561
20.8　實例1：依賴請求隊列的RamDisk　562
20.9　在嵌入式設備上測試塊設備驅動　567
20.9.1　編譯、配置和安裝Busybox　567
20.9.2　測試塊設備驅動　569
20.10　實例2：不依賴請求隊列的RamDisk　570
20.11　扇區與磁盤碎片整理　576
20.12　小結　577

第21章　網絡設備驅動　578
21.1　Linux網絡設備驅動的結構　578
21.1.1　網絡協議接口層　579
21.1.2　網絡設備接口層　583
21.1.3　設備驅動功能層　585
21.1.4　網絡設備與媒介層　585
21.2　網絡設備驅動設計與實現　586
21.2.1　網絡設備的注冊與注銷　586
21.2.2　網絡設備的初始化　587
21.2.3　網絡設備的打開與釋放　588
21.2.4　發送數據　589
21.2.5　接收數據　590
21.2.6　網絡連接狀態　590
21.3　示例：DM9000網卡設備驅動　591
21.3.1　如何確定S3C6410開發板使用的網絡設備　591
21.3.2　DM9000網卡硬件描述　591
21.3.3　網絡設備驅動的定義與安裝　592
21.3.4　初始化DM9000網卡設備驅動　593
21.3.5　移出網絡設備　597
21.3.6　打開和停止DM9000網卡　598
21.3.7　發送數據　600
21.3.8　接收數據　602
21.3.9　設置廣播地址　605
21.4　小結　606

第22章　USB驅動　607
22.1　USB設備簡介　607
22.2　USB驅動與USB核心之間的交互　608
22.2.1　端點(Endpoint)　608
22.2.2　接口(Interfaces)　609
22.2.3　配置(Config)　609
22.3　USB設備的核心數據結構　610
22.3.1　USB設備：usb_device結構體　610
22.3.2　USB驅動：usb_driver結構體　611
22.3.3　識別USB設備：usb_device_id結構體　612
22.3.4　USB端點：usb_host_endpoint結構體　613
22.3.5　USB接口：usb_interface結構體　613
22.3.6　USB配置：usb_host_config結構體　614
22.4　描述符數據結構　615
22.4.1　設備描述符　615
22.4.2　配置描述符　615
22.4.3　接口描述符　615
22.4.4　端點描述符　616
22.4.5　字符串描述符　616
22.4.6　查看描述符信息　616
22.5　USB和sysfs　618
22.6　URB(USB請求塊)　620
22.6.1　URB結構體　621
22.6.2　URB的處理流程　622
22.6.3　簡單的批量與控制URB　625
22.7　USB驅動程序的結構　626
22.8　鼠標驅動分析　633
22.9　小結　637